from tqdm import tqdm
import torch
import numpy as np
import pickle
from .metrics import (
    crps_batch_per_marginal, energy_score_per_batch, variogram_score_per_batch,
    quantile_score_per_batch, dm_pvalue_matrix, roc_for_real_vs_fake)
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error
from typing import List
import seaborn as sns

def make_24h_forecast_with_bands(model, context, samples=100):
    """
    Makes a forecast for the next 24 hours

    model: Trained model
    context: tensor with context the weather conditions of the day [B, c_dim]
             Context must be scaled
    samples: the size of the samples generated by flow

    Returns: (Q1, median, Q3) numpy arrays
    """
    model.eval()
    device = next(model.parameters()).device

    Q1, median, Q3 = [], [], []
    context = context.to(device)

    prediction_quantiles = model.quantiles(context, [0.25, 0.50, 0.75], n=samples)
    Q1 = prediction_quantiles[0,:,:]
    median = prediction_quantiles[1,:,:]
    Q3 = prediction_quantiles[2,:,:]

    return Q1, median, Q3

def plot_wind_forecasts(model, prediction_loader, save_path=None, **kwargs):
    device = next(model.parameters()).device
    model.eval()
    dataset = prediction_loader.create_dataset(shuffle=False, filter_hours=kwargs.get('filter_hours', []))
    target_names = ['TARGETVAR' + str(h) for h in range(1, 25)]
    zones = ['ZONE_' + str(i) for i in range(1, 10 + 1)]
    samples = kwargs.get('samples', 100)
    
    fig, axes = plt.subplots(nrows=5, ncols=2, figsize=(12,14), sharex=True, sharey=True)
    axes = axes.flatten()

    pbar = tqdm(zones, desc="Predict Zones", leave=False)
    for axe, zone in zip(axes, pbar):
        df_zone = dataset[dataset[zone] == 1]
        targets = df_zone[target_names].values.reshape(-1)
        contexts = df_zone.drop(columns=target_names)
        contexts_scaled = prediction_loader.x_scaler.transform(contexts)
        c = torch.from_numpy(contexts_scaled).to(torch.float)
        c = c.to(device)
        Q1, median, Q3 = make_24h_forecast_with_bands(model, c, samples=samples)
        Q1 = prediction_loader.y_scaler.inverse_transform(Q1).reshape(-1)
        median = prediction_loader.y_scaler.inverse_transform(median).reshape(-1)
        Q3 = prediction_loader.y_scaler.inverse_transform(Q3).reshape(-1)

        mae = mean_absolute_error(targets, median)
        axe.fill_between(np.arange(len(targets))/24, Q1, Q3, alpha=0.2)
        axe.plot(np.arange(len(targets))/24, median, label='median')
        axe.plot(np.arange(len(targets))/24, targets, label='targets')
        axe.set_title(f"{zone} (MAE={mae:.2f})")
        axe.set_ylim(0, 1)
        axe.legend()
        axe.set_ylabel('Power')
        axe.set_xlabel('Day')

    fig.tight_layout()
    if save_path is not None:
        fig.savefig(save_path)

def compare_models_on_wind_forecasts(prediction_loader, models: List, save_path=None, **kwargs):
    device = next(models[0].parameters()).device
    for model in models:
        model.eval()
    dataset = prediction_loader.create_dataset(shuffle=False, filter_hours=kwargs.get('filter_hours', []))
    random_day = dataset.sample(n=1)
    target_names = ['TARGETVAR' + str(h) for h in range(1, 25)]
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(12,14))
    ax.plot(np.arange(1, 25), random_day[target_names].values.reshape(-1), label='Target')
    samples = kwargs.get('samples', 100)
    context = random_day.drop(columns=target_names)
    context_scaled = prediction_loader.x_scaler.transform(context)
    c = torch.from_numpy(context_scaled).to(torch.float)
    c = c.to(device)
    for model in models:
        _, median, _ = make_24h_forecast_with_bands(model, c, samples=samples)
        median = prediction_loader.y_scaler.inverse_transform(median)
        ax.plot(np.arange(1, 25), median.reshape(-1), label=model.__class__.__name__)
    ax.set_ylim(0, 1)
    ax.set_ylabel('Power')
    ax.set_xlabel('Hour')
    ax.legend()
    if save_path is not None:
        fig.savefig(save_path)
    
def plot_solar_forecasts(model, prediction_loader, save_path=None, **kwargs):
    device = next(model.parameters()).device
    model.eval()
    dataset = prediction_loader.create_dataset(shuffle=False, filter_hours=kwargs.get('filter_hours', []))
    active_hours = prediction_loader.active_hours
    target_names = ['POWER' + str(h) for h in active_hours]
    zones = ['ZONE_' + str(i) for i in range(1, 3 + 1)]
    samples = kwargs.get('samples', 100)
    
    fig, axes = plt.subplots(nrows=3, ncols=1, figsize=(12,14), sharex=True, sharey=True)
    axes = axes.flatten()

    pbar = tqdm(zones, desc="Predict Zones", leave=False)
    for axe, zone in zip(axes, pbar):
        df_zone = dataset[dataset[zone] == 1]
        targets = df_zone[target_names].values.reshape(-1)
        contexts = df_zone.drop(columns=target_names)
        contexts_scaled = prediction_loader.x_scaler.transform(contexts)
        c = torch.from_numpy(contexts_scaled).to(torch.float)
        c = c.to(device)
        Q1, median, Q3 = make_24h_forecast_with_bands(model, c, samples=samples)
        Q1 = prediction_loader.y_scaler.inverse_transform(Q1).reshape(-1)
        median = prediction_loader.y_scaler.inverse_transform(median).reshape(-1)
        Q3 = prediction_loader.y_scaler.inverse_transform(Q3).reshape(-1)

        mae = mean_absolute_error(targets, median)
        axe.fill_between(np.arange(len(targets))/len(active_hours), Q1, Q3, alpha=0.2)
        axe.plot(np.arange(len(targets))/len(active_hours), median, label='median')
        axe.plot(np.arange(len(targets))/len(active_hours), targets, label='targets')
        axe.set_title(f"{zone} (MAE={mae:.2f})")
        axe.legend()
        axe.set_ylabel('Power')
        axe.set_xlabel('Day')


    fig.tight_layout()
    if save_path is not None:
        fig.savefig(save_path)

def compare_models_on_solar_forecasts(prediction_loader, models: List, save_path=None, **kwargs):
    device = next(models[0].parameters()).device
    for model in models:
        model.eval()
    dataset = prediction_loader.create_dataset(shuffle=False, filter_hours=kwargs.get('filter_hours', []))
    random_day = dataset.sample(n=1)
    active_hours = prediction_loader.active_hours
    target_names = ['POWER' + str(h) for h in active_hours]
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(12,14))
    ax.plot(np.arange(1, len(active_hours) + 1), random_day[target_names].values.reshape(-1), label='Target')
    samples = kwargs.get('samples', 100)
    context = random_day.drop(columns=target_names)
    context_scaled = prediction_loader.x_scaler.transform(context)
    c = torch.from_numpy(context_scaled).to(torch.float)
    c = c.to(device)
    for model in models:
        _, median, _ = make_24h_forecast_with_bands(model, c, samples=samples)
        median = prediction_loader.y_scaler.inverse_transform(median)
        ax.plot(np.arange(1, len(active_hours) + 1), median.reshape(-1), label=model.__class__.__name__)
    ax.set_ylabel('Power')
    ax.set_xlabel('Hour')
    ax.legend()
    if save_path is not None:
        fig.savefig(save_path)


def plot_load_forecasts(model, prediction_dataloader, save_path=None, **kwargs):
    device = next(model.parameters()).device
    model.eval()
    dataset = prediction_dataloader.create_dataset(shuffle=False, filter_hours=kwargs.get('filter_hours', []))
    target_names = ['LOAD' + str(h) for h in range(1, 25)]
    samples = kwargs.get('samples', 100)
    
    fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(12,14))

    targets = dataset[target_names].values.reshape(-1)
    contexts = dataset.drop(columns=target_names)
    contexts_scaled = prediction_dataloader.x_scaler.transform(contexts)
    c = torch.from_numpy(contexts_scaled).to(torch.float)
    c = c.to(device)
    Q1, median, Q3 = make_24h_forecast_with_bands(model, c, samples=samples)
    Q1 = prediction_dataloader.y_scaler.inverse_transform(Q1).reshape(-1)
    median = prediction_dataloader.y_scaler.inverse_transform(median).reshape(-1)
    Q3 = prediction_dataloader.y_scaler.inverse_transform(Q3).reshape(-1)

    mae = mean_absolute_error(targets, median)
    axes.fill_between(np.arange(len(targets))/24, Q1, Q3, alpha=0.2)
    axes.plot(np.arange(len(targets))/24, median, label='median')
    axes.plot(np.arange(len(targets))/24, targets, label='targets')
    axes.set_title(f"(MAE={mae:.2f})")
    axes.legend()
    axes.set_ylabel('Power')
    axes.set_xlabel('Day')

    fig.tight_layout()

    if save_path is not None:
        plt.savefig(save_path)

    return fig, axes

def compare_models_on_load_forecasts(prediction_loader, models: List, save_path=None, **kwargs):
    device = next(models[0].parameters()).device
    for model in models:
        model.eval()
    dataset = prediction_loader.create_dataset(shuffle=False, filter_hours=kwargs.get('filter_hours', []))
    random_day = dataset.sample(n=1)
    target_names = ['LOAD' + str(h) for h in range(1, 25)]
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(12,14))
    ax.plot(np.arange(1, 25), random_day[target_names].values.reshape(-1), label='Target')
    samples = kwargs.get('samples', 100)
    context = random_day.drop(columns=target_names)
    context_scaled = prediction_loader.x_scaler.transform(context)
    c = torch.from_numpy(context_scaled).to(torch.float)
    c = c.to(device)
    for model in models:
        _, median, _ = make_24h_forecast_with_bands(model, c, samples=samples)
        median = prediction_loader.y_scaler.inverse_transform(median)
        ax.plot(np.arange(1, 25), median.reshape(-1), label=model.__class__.__name__)
    ax.set_ylabel('Power')
    ax.set_xlabel('Hour')
    ax.legend()
    if save_path is not None:
        fig.savefig(save_path)

def plot_correlations(model, context, scaler, save_path: str=None, title: str = 'Correlations'):
    device = next(model.parameters()).device
    model.eval()
    context_scaled = scaler.transform(context)
    c = torch.from_numpy(context_scaled).to(torch.float)
    c = c.to(device)
    scenarios = model.sample(n=50, c=c) # (50, T)
    scenarios = scenarios.reshape(-1, 24)
    scenarios_np = scenarios.detach().cpu().numpy()
    correlations = np.corrcoef(scenarios_np, rowvar=False)

    fig, ax = plt.subplots(figsize=(6, 5))
    sns.heatmap(correlations, 
                cmap="RdYlGn_r",
                vmin=-1, vmax=1,
                square=True, 
                cbar=True,
                xticklabels=False,
                yticklabels=False,
                ax=ax)

    ax.set_title(title)
    fig.tight_layout()

    if save_path is not None:
        plt.savefig(save_path)

    return fig, ax


def evaluate_model(model, test_dataloader, model_label, save_path=None, **kwargs):
    n_samples = kwargs.get('samples', 20)
    device = kwargs.get('device', next(model.parameters()).device)

    model.eval()
    all_crps, all_energy, all_vario, all_q = [], [], [], []

    with torch.no_grad():
        pbar = tqdm(test_dataloader, desc=f"Evaluating", leave=False)
        for x, label in pbar:
            x = x.to(device)
            label = label.to(device)

            c_batch = x.reshape(x.size(0), -1)   # [B, c_dim]
            x_batch = label                   # [B, x_dim]

            y_samps = model.sample(n_samples, c_batch)     # (S, B, D)
            y_np = y_samps.detach().cpu().numpy()
            x_np = x_batch.detach().cpu().numpy()

            all_crps.extend(crps_batch_per_marginal(y_np, x_np))
            all_energy.extend(energy_score_per_batch(y_np, x_np))
            all_vario.extend(variogram_score_per_batch(y_np, x_np))

            

            quantiles = model.quantiles(c_batch, q=np.arange(0.01, 1.0, 0.01), n=n_samples)
            all_q.append(np.array([quantile_score_per_batch(quantiles, x_np, q) for q in range(1, 100)]))

    all_crps = np.array(all_crps)
    all_energy = np.array(all_energy)
    all_vario = np.array(all_vario)
    all_q = np.concatenate(all_q, axis=1) # (99, days, T)

    results = {
        'label': model_label,
        'crps': all_crps,
        'energy': all_energy,
        'variogram': all_vario,
        'quantile': all_q
    }

    if save_path is not None:
        with open(save_path, 'wb') as f:
            pickle.dump(results, f)
    return results

def plot_qs(quantiles: List[List[np.ndarray]], labels: List[str], save_path: str =None, title: str = 'Quantile Score'):
    fig, ax = plt.subplots(figsize=(8, 5))

    for quantile, label in zip(quantiles, labels):
        q = np.mean(quantile, axis=1) # (99, T)
        ax.plot(np.arange(1, 100, 1), q.mean(axis=1), label=label)

    ax.set_xlabel('Quantile')
    ax.set_ylabel('Score')
    ax.set_title(title)
    ax.set_xlim(1, 100)
    ax.legend()

    if save_path is not None:
        plt.savefig(save_path)

    return fig, ax

def plot_crps(crps: List[np.ndarray], labels: List[str], save_path: str =None, title: str = 'CRPS'):
    fig, ax = plt.subplots(figsize=(8, 5))

    for crp, label in zip(crps, labels):
        c = np.mean(crp, axis=0) # (T)
        ax.plot(np.arange(1, len(c)+1), c, label=label)

    ax.set_xlabel('Hour')
    ax.set_ylabel('Score')
    ax.set_title(title)
    ax.set_xlim(1, len(c)+1)
    ax.legend()

    if save_path is not None:
        plt.savefig(save_path)

    return fig, ax

def plot_dm(losses, labels, h=1, save_path=None, title='Diebold-Mariano Test'):
    fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(8, 6), constrained_layout=True)
    axes = ax.flatten()

    mask = np.eye(len(labels), dtype=bool)

    for axe, (loss_type, loss_dict) in zip(axes, losses.items()):
        p_values = dm_pvalue_matrix(loss_dict, labels, h=h).clip(upper=0.1)

        heatmap_obj = sns.heatmap(
            p_values, 
            annot=True, fmt=".2f",
            cmap='RdYlGn_r', vmin=0, vmax=0.1,
            square=True, cbar=False,
            xticklabels=labels, yticklabels=labels,
            mask=mask, ax=axe
        )
        axe.set_title(f"{loss_type} DM test")
        axe.tick_params(left=False, bottom=False)

    # Add ONE shared colorbar
    cbar = fig.colorbar(heatmap_obj.get_children()[0], ax=axes, 
                        location="right", fraction=0.03, pad=0.04)
    cbar.set_label("p-value (capped at 0.10)")

    fig.suptitle(title, y=1.02)

    if save_path is not None:
        fig.savefig(save_path, bbox_inches="tight")

    return fig, ax

def collect_real_features(prediction_loader):
    X_real = []
    for c_batch, y_batch in prediction_loader:
        X_real.append(y_batch.detach().cpu().numpy())  # (batch, T)
    return np.vstack(X_real)  # (n_days, T)

@torch.no_grad()
def collect_fake_features(model, prediction_loader, device, n_runs=50, T=24):
    model.eval()
    runs = []

    for _ in range(n_runs):
        X_fake = []
        for c_batch, _ in prediction_loader:
            c_batch = c_batch.to(device, dtype=torch.float32)

            y_fake = model.sample(n=1, c=c_batch)
            if torch.is_tensor(y_fake):
                y_fake = y_fake.detach().cpu().numpy()
            arr = np.asarray(y_fake)

            # --- normalize shape to (batch, T) ---
            if arr.ndim == 3 and arr.shape[1] == 1: # (batch, 1, T) -> (batch, T)
                arr = arr[:, 0, :]
            elif arr.ndim == 3 and arr.shape[0] == 1: # (1, batch, T) -> (batch, T)
                arr = arr[0, :, :]
            elif arr.ndim == 2 and arr.shape[0] == T: # (T, batch) -> (batch, T)
                arr = arr.T
            else:
                raise ValueError(f"Unexpected shape: {arr.shape}")

            X_fake.append(arr)

        runs.append(np.vstack(X_fake))  # (n_days, T)

    return runs

def plot_roc_many_scenarios(real_feats, fake_feats_by_model, n_runs=50, 
                            title="Classifier-based metric (Extra Trees)", 
                            save_path=None):
    plt.figure(figsize=(8, 6))
    colors = {"VAE": "tab:orange", "NAF": "tab:blue", "NSF": "tab:green", "GAN": "tab:cyan"}

    for model_name, runs in fake_feats_by_model.items():
        color = colors.get(model_name, "tab:gray")
        for i in range(min(n_runs, len(runs))):
            fpr, tpr, _ = roc_for_real_vs_fake(real_feats, runs[i], 
                                               n_estimators=300, max_depth=None)
            label = model_name if i == 0 else None
            plt.plot(fpr, tpr, lw=1, alpha=1, color=color, label=label)

    plt.plot([0, 1], [0, 1], 'k--', lw=1, alpha=0.6)
    plt.legend()
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.title(title)
    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.tight_layout()

    if save_path is not None:
        plt.savefig(save_path)
